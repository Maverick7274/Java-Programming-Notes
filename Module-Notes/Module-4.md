# IT201 Java Programming

## Module 4

### Event handling mechanism

In Java, event handling is the mechanism by which events generated by user actions or system events are handled by the appropriate code. It allows you to write code that responds to user interactions such as button clicks, mouse movements, key presses, etc. Java provides an event handling framework that consists of event sources, event objects, and event listeners. Here's an overview of the event handling mechanism in Java:

1. Event Sources:
   - Event sources are objects that generate events.
   - Examples of event sources include buttons, menus, text fields, etc.
   - These objects are typically part of a graphical user interface (GUI) or other interactive components.

2. Event Objects:
   - Event objects encapsulate information about the event that occurred.
   - Each type of event has a corresponding event class (e.g., `ActionEvent`, `MouseEvent`, `KeyEvent`) that provides methods to access event-specific information.
   - The event object is created and passed to the event handling code when an event occurs.

3. Event Listeners:
   - Event listeners are interfaces or classes that define callback methods to handle specific types of events.
   - They are responsible for implementing the logic that responds to the events.
   - Each listener interface or class typically contains one or more methods that need to be implemented.
   - Event listeners are registered with the event source to receive and handle events.

4. Event Registration:
   - To handle events, event listeners need to be registered with the event source.
   - This is typically done using the `addActionListener()`, `addMouseListener()`, or similar methods provided by the event source.
   - The event source maintains a list of registered listeners and invokes their callback methods when an event occurs.

5. Event Dispatching:
   - When an event occurs, the event source creates an event object and dispatches it to all registered event listeners.
   - The appropriate callback method(s) of the registered listeners are invoked, and they perform the desired actions based on the event.

Here's a simplified example that demonstrates event handling for a button click using the `ActionListener` interface:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;

public class EventHandlingExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Event Handling Example");

        JButton button = new JButton("Click Me");
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Button clicked!");
            }
        });

        frame.add(button);
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

In the above example:
- We create a `JFrame` window to hold the GUI components.
- We create a `JButton` and set its text to "Click Me".
- We register an anonymous inner class implementing the `ActionListener` interface as the button's event listener.
- Inside the `actionPerformed()` method, we define the code that will be executed when the button is clicked. In this case, it simply prints a message to the console.
- The button is added to the frame, and the frame is displayed.

When the button is clicked, the `actionPerformed()` method of the registered `ActionListener` is called, and the message "Button clicked!" is printed to the console.

This is a basic example, and in real-world applications, you can handle various types of events, register multiple listeners, and perform more complex actions based on the events that occur.


### Event Model

The event model in Java is a framework that allows you to handle and respond to events generated by user actions or system events. It follows a standardized approach for event handling across different components and provides a consistent way to write event-driven code. The event model consists of three main components: event sources, event objects, and event listeners.

1. Event Sources:
   - Event sources are objects that generate events. They can be GUI components such as buttons, menus, text fields, etc., or other entities that produce events in the system.
   - Event sources provide methods to register event listeners and notify them when events occur.
   - Event sources typically implement interfaces or extend classes that define the methods for event registration and notification.

2. Event Objects:
   - Event objects encapsulate information about the event that occurred. They are instances of event classes specific to the type of event.
   - Each event class provides methods to access event-specific information, such as the source of the event, event type, event parameters, etc.
   - Event objects are created and populated by the event source when an event occurs.

3. Event Listeners:
   - Event listeners are interfaces or classes that define callback methods to handle specific types of events.
   - Each event listener interface or class typically contains one or more methods that need to be implemented.
   - Event listeners are responsible for implementing the logic that responds to the events.
   - Event listeners are registered with the event source using appropriate registration methods.

The event model follows the Observer design pattern, where event listeners are observers and event sources are subjects. When an event occurs, the event source notifies all registered event listeners by invoking their callback methods. The event object is typically passed as an argument to the callback method, allowing the listener to access event-specific information.

By using the event model, you can write event-driven code that separates the concerns of event generation and event handling. It promotes modular and reusable code, as event sources and listeners can be easily connected or disconnected without impacting other parts of the application.

Java provides various event models depending on the framework or library being used. Some popular event models in Java include:

- AWT (Abstract Window Toolkit) Event Model: Used in Java's original GUI framework, provides event handling for AWT components.
- Swing Event Model: A more advanced event model built on top of AWT, provides event handling for Swing components with enhanced features.
- JavaFX Event Model: Used in JavaFX framework, provides a rich event handling mechanism for building modern, rich client applications.

Each event model follows a similar pattern of event sources, event objects, and event listeners, but may have specific interfaces and classes tailored to the framework's requirements.

By understanding and utilizing the event model, you can create interactive and responsive applications that respond to user actions and system events effectively.

### Event Classes

In Java, event classes are specific classes that represent different types of events that can occur in an application. These event classes are part of the event model and provide information about the event that occurred. They typically contain methods and fields to access event-specific data such as the event source, event type, event parameters, and other relevant information.

Here are some commonly used event classes in Java:

1. `ActionEvent`:
   - Represents an action performed by the user, such as clicking a button, selecting a menu item, or pressing Enter in a text field.
   - Contains methods to retrieve information about the action event, such as the source of the event, the action command associated with the event, and the modifiers (e.g., Ctrl, Shift) that were pressed during the action.

2. `MouseEvent`:
   - Represents a mouse-related event, such as clicking, dragging, or moving the mouse.
   - Provides methods to retrieve information about the mouse event, such as the source of the event, the coordinates of the mouse pointer, the button that was pressed or released, and the modifiers (e.g., Ctrl, Shift) that were pressed during the event.

3. `KeyEvent`:
   - Represents a keyboard-related event, such as pressing or releasing a key on the keyboard.
   - Contains methods to retrieve information about the key event, such as the source of the event, the key code of the pressed or released key, the character representation of the key, and the modifiers (e.g., Ctrl, Shift) that were pressed during the event.

4. `WindowEvent`:
   - Represents a window-related event, such as opening, closing, resizing, or moving a window.
   - Provides methods to retrieve information about the window event, such as the source of the event, the type of window operation that occurred, and any additional data associated with the event.

5. `FocusEvent`:
   - Represents a focus-related event, such as gaining or losing focus on a component.
   - Contains methods to retrieve information about the focus event, such as the source of the event, the type of focus change that occurred (e.g., gained focus, lost focus), and the component that previously had the focus.

These are just a few examples of event classes in Java. Different frameworks and libraries may introduce additional event classes specific to their functionalities. When working with event handling, you need to understand the specific event classes associated with the framework or library you are using and use their methods and fields to access the relevant event data.

By utilizing event classes, you can extract and process event-specific information to perform appropriate actions or trigger specific behavior in response to user actions or system events in your Java applications.

### Source of Events

In Java, events can originate from various sources in an application. These event sources are objects that generate events when specific actions or conditions occur. Event sources can include graphical user interface (GUI) components, system-level events, and other entities within the application. Here are some common sources of events in Java:

1. GUI Components:
   - GUI components such as buttons, menus, text fields, checkboxes, and radio buttons can generate events.
   - These components are typically part of a graphical user interface framework like AWT, Swing, or JavaFX.
   - Examples of events generated by GUI components include button clicks, menu item selections, text input changes, and mouse actions.

2. System-Level Events:
   - System-level events are generated by the operating system or the Java Virtual Machine (JVM) itself.
   - These events are not directly tied to GUI components but can affect the application's behavior or execution.
   - Examples of system-level events include window-related events (e.g., window opening, closing), keyboard events, mouse events, and focus events.

3. Timer Events:
   - Timer events are generated by timer objects that allow you to schedule and execute tasks at specified intervals.
   - The `javax.swing.Timer` class or the `java.util.Timer` class can be used to create timers and generate timer events.
   - Timer events can be used to trigger specific actions periodically or after a certain delay.

4. Custom Event Sources:
   - Apart from GUI components and system-level events, you can also create your own custom event sources.
   - Custom event sources are typically classes that encapsulate certain behaviors or conditions and generate events when those behaviors or conditions occur.
   - For example, you might define a custom event source that generates events when a specific condition is met, such as reaching a certain threshold or receiving data from an external source.

Event-driven frameworks and libraries often provide specific event sources tailored to their functionality. For example, the JavaFX framework provides event sources like `javafx.scene.Node` objects for GUI events, while the Java AWT framework provides event sources like `java.awt.Component` objects.

To handle events, event listeners are registered with the event sources to receive and process the events. The event listeners implement callback methods that are invoked when events occur, allowing you to define the desired behavior or action to be performed in response to those events.

Understanding the sources of events in Java is crucial for effective event handling and building responsive applications that can interact with user actions and system events.

### Event Listener Interfaces

In Java, event listener interfaces define the contract for implementing event handling code. These interfaces provide a set of methods that need to be implemented by event listener classes to handle specific types of events. By implementing these interfaces and providing the necessary callback methods, you can respond to events generated by various event sources in your application.

Here are some commonly used event listener interfaces in Java:

1. `ActionListener`:
   - This interface is used to handle action events, which are typically generated by GUI components like buttons and menu items when they are clicked or activated.
   - It defines a single method: `actionPerformed(ActionEvent e)`. This method is called when an action event occurs, allowing you to perform the desired action in response to the event.

2. `MouseListener`:
   - This interface is used to handle mouse events, which occur when the user interacts with GUI components using the mouse.
   - It defines several methods, including `mouseClicked(MouseEvent e)`, `mousePressed(MouseEvent e)`, `mouseReleased(MouseEvent e)`, `mouseEntered(MouseEvent e)`, and `mouseExited(MouseEvent e)`. These methods are invoked when specific mouse actions occur, allowing you to respond accordingly.

3. `KeyListener`:
   - This interface is used to handle keyboard events, which occur when the user interacts with GUI components using the keyboard.
   - It defines methods like `keyPressed(KeyEvent e)`, `keyReleased(KeyEvent e)`, and `keyTyped(KeyEvent e)` to handle different types of keyboard events.

4. `WindowListener`:
   - This interface is used to handle window-related events, such as opening, closing, resizing, or moving a window.
   - It defines methods like `windowOpened(WindowEvent e)`, `windowClosing(WindowEvent e)`, `windowClosed(WindowEvent e)`, `windowIconified(WindowEvent e)`, and `windowDeiconified(WindowEvent e)` to handle different window events.

5. `FocusListener`:
   - This interface is used to handle focus events, which occur when a component gains or loses focus.
   - It defines methods like `focusGained(FocusEvent e)` and `focusLost(FocusEvent e)` to handle focus-related events.

These are just a few examples of event listener interfaces in Java. Different frameworks and libraries may provide additional listener interfaces specific to their functionalities.

To handle events, you need to create a class that implements the appropriate listener interface and provides the necessary implementation for the callback methods. You then register an instance of this listener class with the event source using methods like `addActionListener()`, `addMouseListener()`, or `addKeyListener()`, depending on the event source and the type of events you want to handle.

When an event occurs, the event source invokes the corresponding callback method(s) of the registered listener, passing an event object as an argument. Inside these methods, you can write the code to respond to the event and perform the desired actions.

Using event listener interfaces, you can build event-driven applications in Java, where the behavior of the application is driven by user actions or system events.

### Event Listeners

In Java, event listeners are classes or objects that implement specific interfaces to handle events generated by event sources. They are responsible for defining the behavior or actions to be taken when a particular event occurs. Event listeners are an essential part of event-driven programming, allowing developers to write code that responds to user actions or system events.

Here are the key aspects of event listeners in Java:

1. Interface Implementation:
   - Event listeners in Java are typically implemented as classes that implement a specific event listener interface.
   - Each type of event corresponds to a specific listener interface, such as `ActionListener`, `MouseListener`, `KeyListener`, etc.
   - Event listener interfaces define the required methods that need to be implemented by the listener class.

2. Event Registration:
   - Once an event listener class is created, it needs to be registered with the event source to receive events.
   - Event registration is done using appropriate methods provided by the event source, such as `addActionListener()` or `addMouseListener()`.
   - The event source maintains a list of registered listeners and invokes their respective methods when events occur.

3. Event Handling:
   - When an event occurs, the event source invokes the appropriate method(s) of the registered event listener(s).
   - The listener's method(s) are called with an event object that contains information about the event.
   - Event listener classes implement the logic to handle the event, which can include modifying the program's state, updating the user interface, or triggering other actions.

4. Callback Methods:
   - Event listener interfaces define one or more callback methods that need to be implemented by the listener class.
   - These methods are invoked by the event source to notify the listener about the occurrence of a specific event.
   - The listener class provides the implementation for these methods based on the desired behavior or actions to be taken in response to the event.

5. Anonymous Listeners:
   - In Java, it is also possible to use anonymous inner classes to create event listeners inline without explicitly creating a separate class.
   - This approach allows for more concise code when the event handling logic is relatively simple.

By implementing event listeners and registering them with appropriate event sources, you can create interactive and responsive applications in Java. Event listeners enable you to define the behavior of your application based on user actions, such as button clicks, mouse movements, keyboard input, or system events like window closing or opening.

### AWT : Working with Windows

Working with windows in AWT (Abstract Window Toolkit) involves creating and managing graphical windows or frames in Java applications. AWT provides classes and methods for creating windows, adding components to them, handling events, and managing their appearance and behavior. Here's an overview of how to work with windows in AWT:

1. Create a Window:
   - To create a window, you typically use the `Frame` class, which represents a top-level window in AWT.
   - Create an instance of the `Frame` class and set its properties, such as title, size, and layout.
   - For example:
     ```java
     import java.awt.Frame;
     
     public class MyWindow {
         public static void main(String[] args) {
             Frame frame = new Frame("My Window");
             frame.setSize(400, 300);
             frame.setVisible(true);
         }
     }
     ```

2. Add Components:
   - After creating a window, you can add components to it using layout managers.
   - A layout manager controls the positioning and sizing of components within the window.
   - Common layout managers include `FlowLayout`, `BorderLayout`, `GridLayout`, and `GridBagLayout`.
   - Use the `add()` method of the `Container` class (which `Frame` extends) to add components to the window.
   - For example:
     ```java
     import java.awt.Frame;
     import java.awt.Button;
     import java.awt.FlowLayout;
     
     public class MyWindow {
         public static void main(String[] args) {
             Frame frame = new Frame("My Window");
             frame.setLayout(new FlowLayout());
             
             Button button1 = new Button("Button 1");
             Button button2 = new Button("Button 2");
             
             frame.add(button1);
             frame.add(button2);
             
             frame.setSize(400, 300);
             frame.setVisible(true);
         }
     }
     ```

3. Handle Window Events:
   - AWT provides event listener interfaces and methods to handle window-related events, such as window closing or resizing.
   - Implement the `WindowListener` interface and override its methods to define the behavior when these events occur.
   - Use the `addWindowListener()` method to register the listener with the window.
   - For example:
     ```java
     import java.awt.Frame;
     import java.awt.event.WindowAdapter;
     import java.awt.event.WindowEvent;
     
     public class MyWindow {
         public static void main(String[] args) {
             Frame frame = new Frame("My Window");
             frame.setSize(400, 300);
             
             frame.addWindowListener(new WindowAdapter() {
                 public void windowClosing(WindowEvent e) {
                     System.exit(0);
                 }
             });
             
             frame.setVisible(true);
         }
     }
     ```

4. Customize Appearance and Behavior:
   - AWT provides various methods to customize the appearance and behavior of windows.
   - You can set the window's title, size, position, visibility, and resizable properties using appropriate methods.
   - Additionally, you can set the window's icon, change its background color, and modify its default close operation.
   - Explore the methods available in the `Frame` class to adjust these properties.

Working with windows in AWT involves creating a `Frame`, adding components to it, handling events, and configuring its appearance and behavior. By using layout managers and event listeners, you can create interactive graphical windows in your Java applications.

### AWT : controls

AWT (Abstract Window Toolkit) provides a set of controls or components that can be used to create graphical user interfaces (GUIs) in Java applications. These controls are part of the `java.awt` package and offer a range of functionalities for building interactive user interfaces. Here are some commonly used AWT controls in Java:

1. Button:
   - The `Button` class represents a push button control.
   - It can display text or an image and can generate events when clicked.
   - Example:
     ```java
     import java.awt.Button;
     
     Button button = new Button("Click Me");
     ```

2. Label:
   - The `Label` class represents a non-editable text display area.
   - It is used to display static text or descriptive information.
   - Example:
     ```java
     import java.awt.Label;
     
     Label label = new Label("Hello World");
     ```

3. TextField:
   - The `TextField` class provides a single-line input text field.
   - It allows users to enter and edit text.
   - Example:
     ```java
     import java.awt.TextField;
     
     TextField textField = new TextField(20);
     ```

4. TextArea:
   - The `TextArea` class provides a multi-line text editing area.
   - It allows users to enter and edit multiple lines of text.
   - Example:
     ```java
     import java.awt.TextArea;
     
     TextArea textArea = new TextArea(5, 20);
     ```

5. Checkbox:
   - The `Checkbox` class represents a checkbox control.
   - It allows users to select one or more options from a list of choices.
   - Example:
     ```java
     import java.awt.Checkbox;
     
     Checkbox checkbox = new Checkbox("Option 1");
     ```

6. Choice:
   - The `Choice` class represents a drop-down list of selectable items.
   - It allows users to select one item from a list of options.
   - Example:
     ```java
     import java.awt.Choice;
     
     Choice choice = new Choice();
     choice.add("Option 1");
     choice.add("Option 2");
     ```

7. List:
   - The `List` class represents a scrollable list of selectable items.
   - It allows users to select one or more items from a list.
   - Example:
     ```java
     import java.awt.List;
     
     List list = new List(4, true);
     list.add("Item 1");
     list.add("Item 2");
     ```

8. CheckboxGroup:
   - The `CheckboxGroup` class is used to group related checkboxes together.
   - It ensures that only one checkbox in the group can be selected at a time.
   - Example:
     ```java
     import java.awt.Checkbox;
     import java.awt.CheckboxGroup;
     
     CheckboxGroup checkboxGroup = new CheckboxGroup();
     Checkbox checkbox1 = new Checkbox("Option 1", checkboxGroup, false);
     Checkbox checkbox2 = new Checkbox("Option 2", checkboxGroup, false);
     ```

These are just a few examples of AWT controls available in Java. Each control provides specific methods and properties to customize its appearance and behavior. By using these controls, you can create interactive user interfaces for your Java applications.

### AWT : Layout Managers

Layout managers in AWT (Abstract Window Toolkit) are classes that control the positioning and sizing of components within a container. They provide a way to arrange and manage the layout of GUI components in a flexible and platform-independent manner. AWT provides several layout managers to suit different layout requirements. Here are some commonly used layout managers in Java:

1. FlowLayout:
   - `FlowLayout` arranges components in a left-to-right flow, wrapping them to the next line if necessary.
   - Components are placed one after another, respecting their preferred sizes.
   - Example:
     ```java
     import java.awt.FlowLayout;
     import java.awt.Frame;
     import java.awt.Button;
     
     Frame frame = new Frame("FlowLayout Example");
     frame.setLayout(new FlowLayout());
     frame.add(new Button("Button 1"));
     frame.add(new Button("Button 2"));
     frame.add(new Button("Button 3"));
     ```

2. BorderLayout:
   - `BorderLayout` divides the container into five regions: North, South, East, West, and Center.
   - Components added to these regions are positioned accordingly.
   - The center region expands to fill any remaining space.
   - Example:
     ```java
     import java.awt.BorderLayout;
     import java.awt.Frame;
     import java.awt.Button;
     
     Frame frame = new Frame("BorderLayout Example");
     frame.setLayout(new BorderLayout());
     frame.add(new Button("North"), BorderLayout.NORTH);
     frame.add(new Button("South"), BorderLayout.SOUTH);
     frame.add(new Button("East"), BorderLayout.EAST);
     frame.add(new Button("West"), BorderLayout.WEST);
     frame.add(new Button("Center"), BorderLayout.CENTER);
     ```

3. GridLayout:
   - `GridLayout` arranges components in a grid-like structure with a specified number of rows and columns.
   - Components are added row by row from left to right, top to bottom.
   - All components in the grid have the same size.
   - Example:
     ```java
     import java.awt.GridLayout;
     import java.awt.Frame;
     import java.awt.Button;
     
     Frame frame = new Frame("GridLayout Example");
     frame.setLayout(new GridLayout(2, 3));
     frame.add(new Button("Button 1"));
     frame.add(new Button("Button 2"));
     frame.add(new Button("Button 3"));
     frame.add(new Button("Button 4"));
     frame.add(new Button("Button 5"));
     frame.add(new Button("Button 6"));
     ```

4. GridBagLayout:
   - `GridBagLayout` is a flexible and powerful layout manager that uses constraints to control the placement of components.
   - It allows components to span multiple rows and columns, and each component can have different sizes.
   - Example:
     ```java
     import java.awt.GridBagLayout;
     import java.awt.Frame;
     import java.awt.Button;
     import java.awt.GridBagConstraints;
     
     Frame frame = new Frame("GridBagLayout Example");
     frame.setLayout(new GridBagLayout());
     GridBagConstraints constraints = new GridBagConstraints();
     
     constraints.gridx = 0;
     constraints.gridy = 0;
     frame.add(new Button("Button 1"), constraints);
     
     constraints.gridx = 1;
     constraints.gridy = 0;
     frame.add(new Button("Button 2"), constraints);
     
     constraints.gridx = 0;
     constraints.gridy = 1;
     constraints.gridwidth = 2;
     frame.add(new Button("Button 3"), constraints);
     ```

These are just a few examples of layout managers available in AWT. Each layout manager has its own set of properties and methods to configure the layout of components within containers. By choosing the appropriate layout manager and adjusting its settings, you can create well-organized

 and resizable GUIs in Java.