# IT201 Question Paper 2015

## Section A

### 1. List and explain the features of Java.

### Answer :

Java is a versatile and widely used programming language known for its platform independence, strong community support, and rich set of features. Here are some of the key features of Java:

1. Simple and Easy to Learn: Java is designed to be simple and easy to learn, especially for developers with a background in C or C++. It has a clean syntax, well-defined conventions, and a minimalistic approach, making it beginner-friendly.

2. Object-Oriented: Java follows the object-oriented programming (OOP) paradigm, which allows developers to organize their code into reusable objects. It supports features such as encapsulation, inheritance, and polymorphism, promoting modular and maintainable code.

3. Platform Independence: One of the standout features of Java is its platform independence. Java programs are compiled into bytecode, which can be executed on any platform with a Java Virtual Machine (JVM). This "write once, run anywhere" capability makes Java highly portable and enables cross-platform compatibility.

4. Automatic Memory Management: Java incorporates automatic memory management through garbage collection. It relieves developers from manually allocating and deallocating memory, reducing the risk of memory leaks and improving overall program stability.

5. Robustness and Error Handling: Java emphasizes robustness and provides built-in mechanisms for exception handling. It uses a checked exception system that enforces proper error handling and promotes more reliable and resilient applications.

6. Rich Standard Library: Java comes with a comprehensive standard library that provides a wide range of classes and APIs for common tasks. It includes libraries for networking, input/output operations, database connectivity, graphical user interfaces, and much more. This extensive standard library accelerates development and simplifies many programming tasks.

7. Multi-threading and Concurrency Support: Java has built-in support for multi-threading and concurrent programming. It provides the `Thread` class and high-level concurrency utilities such as locks, condition variables, and thread pools, enabling developers to create efficient and scalable multi-threaded applications.

8. High Performance: While Java is known for its platform independence, it also offers high performance. The Just-In-Time (JIT) compiler optimizes bytecode into machine code at runtime, allowing Java applications to achieve performance comparable to languages like C and C++.

9. Security: Java places a strong emphasis on security. It includes features like a robust security manager, bytecode verification, and a sandbox model to ensure the safe execution of Java applications, making it a popular choice for developing secure software.

10. Large and Active Community: Java has a large and active community of developers, which means abundant resources, libraries, frameworks, and support are available. The strong community support fosters knowledge sharing, collaboration, and continuous improvement.

These features have contributed to the widespread adoption of Java across various domains, including enterprise software development, web applications, mobile development (Android), scientific computing, and more. Java's versatility and extensive features make it a reliable and powerful programming language for a wide range of applications.

---

### 2. Write a java program to find the factorial of a given number using command line arguments.

### Answer :

Certainly! Here's a Java program that calculates the factorial of a given number using command line arguments:

```java
public class FactorialCalculator {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: java FactorialCalculator <number>");
            return;
        }

        int number = Integer.parseInt(args[0]);
        long factorial = calculateFactorial(number);

        System.out.println("Factorial of " + number + " is: " + factorial);
    }

    private static long calculateFactorial(int number) {
        if (number < 0) {
            throw new IllegalArgumentException("Number must be non-negative.");
        }

        if (number == 0 || number == 1) {
            return 1;
        }

        long factorial = 1;
        for (int i = 2; i <= number; i++) {
            factorial *= i;
        }

        return factorial;
    }
}
```

In this program, the `main()` method first checks if the number of command line arguments is exactly 1. If not, it prints a usage message and terminates the program. The expected usage is `java FactorialCalculator <number>`, where `<number>` is the integer for which the factorial needs to be calculated.

Next, it parses the command line argument (`args[0]`) as an integer using `Integer.parseInt()` and stores it in the `number` variable.

The `calculateFactorial()` method calculates the factorial of the given number using a loop. It starts from 2 and multiplies the current factorial value by each subsequent number up to the given number. The factorial value is stored in the `factorial` variable.

Finally, the program prints the calculated factorial to the console.

To run the program, open a command prompt or terminal, navigate to the directory containing the Java file, and execute the following command:

```
java FactorialCalculator <number>
```

Replace `<number>` with the actual number for which you want to calculate the factorial. The program will display the factorial of the given number.

---

### 3. Give a detailed explanation of packages in Java.

### Answer :

In Java, packages are used to organize and group related classes, interfaces, and other components into a hierarchical structure. They provide a way to manage and control the namespace of classes, avoiding naming conflicts and promoting modularity. Packages also facilitate code organization, reusability, and maintainability in large-scale Java projects.

Here's a detailed explanation of packages in Java:

1. Namespace Management: Packages help manage the namespace of classes and prevent naming conflicts. By organizing classes into different packages, you can use the same class names in different packages without conflicts. Each package creates a separate namespace, ensuring that class names remain unique within that package.

2. Code Organization: Packages provide a structured way to organize code. They help logically group related classes, interfaces, and resources together. For example, a package named `com.example.application` might contain classes related to the application's core functionality, while another package named `com.example.application.ui` might contain user interface-related classes.

3. Access Control: Packages allow you to control access to classes and their members. Java has access modifiers (`public`, `protected`, `private`, and default access) that determine the visibility of classes, methods, and variables. Classes and members declared with the `public` access modifier can be accessed from other packages, while those with default access can only be accessed within the same package.

4. Reusability and Modularity: Packages facilitate code reusability and modularity. You can create reusable libraries by packaging related classes together and distributing them as a package. Other developers can then import and use those packages in their own projects. Packages also promote modularity by encapsulating related classes, making it easier to understand, maintain, and update specific parts of an application without affecting others.

5. Package Hierarchy: Packages in Java can be organized into a hierarchical structure, forming a package hierarchy. A package hierarchy allows you to create a logical structure for your code, similar to a file system hierarchy. For example, you can have a package `com.example` with sub-packages like `com.example.util` and `com.example.ui`. The package hierarchy reflects the organization and relationships between different components of your application.

6. Import Statements: Java uses import statements to access classes and members from other packages. Import statements allow you to use classes and their members without specifying their fully qualified names. By importing the required packages, you can write cleaner and more concise code.

7. Standard Library and External Libraries: Java provides a rich standard library that is organized into packages. These packages contain a wide range of classes and APIs for various tasks, such as I/O operations, networking, data structures, and more. Additionally, external libraries or frameworks also use packages to organize their classes and resources, enabling easy integration and usage.

To use a package in Java, you typically include a package declaration at the beginning of your source file using the `package` keyword. For example:

```java
package com.example.application;

public class MyClass {
    // class code
}
```

In this example, the `MyClass` is defined in the `com.example.application` package. To access classes from other packages, you can use import statements like:

```java
import com.example.util.UtilityClass;

public class AnotherClass {
    // code that uses UtilityClass
}
```

In summary, packages in Java provide a mechanism to organize, manage, and control access to classes and other components. They promote code organization, reusability, modularity, and help manage namespace conflicts. By using packages effectively, you can create well-structured and maintainable Java projects.

---

### 4. What is Multi-threading? Explain with an example. Explain any two advantages of Multi-threaded systems.

### Answer :

Multi-threading refers to the concurrent execution of multiple threads within a single program. It allows different parts of a program to run concurrently, thereby enabling efficient utilization of CPU resources and improving overall system performance. Each thread represents an independent flow of execution, capable of executing tasks in parallel with other threads.

Here's an example to illustrate multi-threading in Java:

```java
class MyThread extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Thread: " + Thread.currentThread().getId() + ", Value: " + i);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();

        thread1.start();
        thread2.start();
    }
}
```

In this example, we define a `MyThread` class that extends the `Thread` class in Java. The `run()` method is overridden to define the tasks that will be executed by each thread. In this case, the threads simply print numbers from 1 to 5 along with their respective thread IDs.

In the `Main` class, we create two instances of `MyThread`, namely `thread1` and `thread2`. We then start both threads using the `start()` method. The `start()` method initiates the execution of the threads, and they run concurrently in parallel.

When the program runs, the output will be similar to the following:

```
Thread: 11, Value: 1
Thread: 12, Value: 1
Thread: 11, Value: 2
Thread: 12, Value: 2
Thread: 11, Value: 3
Thread: 12, Value: 3
Thread: 11, Value: 4
Thread: 12, Value: 4
Thread: 11, Value: 5
Thread: 12, Value: 5
```

The output demonstrates that both threads execute their tasks concurrently, interleaving their outputs.

Advantages of Multi-threaded Systems:

1. Improved Responsiveness and Efficiency: Multi-threading allows for concurrent execution of tasks, which can improve the responsiveness of a system. For example, in a user interface application, the main thread can handle user interactions while background threads perform computationally intensive or time-consuming tasks. This prevents the UI from becoming unresponsive and provides a smoother user experience. Additionally, multi-threading allows for efficient utilization of CPU resources, as multiple threads can execute simultaneously, making better use of available cores.

2. Enhanced Performance and Throughput: By leveraging multi-threading, programs can achieve improved performance and higher throughput. For computationally intensive tasks, dividing the workload among multiple threads can lead to faster execution times. For example, in a data processing application, multiple threads can process different portions of data concurrently, significantly reducing the overall processing time. Multi-threading can also be beneficial in I/O-bound tasks, where threads can overlap I/O operations, reducing waiting time and maximizing CPU utilization.

3. Resource Sharing and Responsiveness: Multi-threading enables efficient resource sharing among threads. Threads within the same process can share common data structures and resources, allowing them to collaborate on complex tasks. For example, multiple threads can access a shared collection or database connection pool, leading to better resource utilization. Moreover, multi-threading facilitates responsiveness in scenarios where a thread needs to wait for certain events or conditions. Instead of blocking the entire program, only the specific thread gets suspended, allowing other threads to continue execution.

4. Modularity and Code Organization: Multi-threading encourages modular and organized code design. By dividing a program's tasks into separate threads, each

 responsible for a specific functionality, code becomes more structured and maintainable. Developers can focus on individual thread implementations and the interaction between them, making it easier to debug, test, and enhance different parts of the program independently.

In summary, multi-threading allows for concurrent execution of tasks, resulting in improved responsiveness, increased efficiency, enhanced performance, and resource sharing. It enables programs to better utilize CPU resources, handle concurrent operations, and provide a better user experience. However, it also requires careful consideration of thread synchronization and coordination to avoid issues like data races and deadlocks.

---

### 5. Explain the following with respect to exception handling in Java:

#### a. try

#### b. catch

#### c. throw

#### d. finally

### Answer :

(a, b, c, d)

In Java, the `try` block is a fundamental component of exception handling. It is used to enclose a block of code that may potentially throw an exception. By placing the code that might generate an exception within a `try` block, you can catch and handle any exceptions that occur, preventing them from causing program termination.

The basic syntax of a `try` block is as follows:

```java
try {
    // Code that may throw an exception
} catch (ExceptionType1 e1) {
    // Exception handling code for ExceptionType1
} catch (ExceptionType2 e2) {
    // Exception handling code for ExceptionType2
} finally {
    // Optional finally block
}
```

Here's a breakdown of each part of the `try` block:

- The code within the `try` block is the section where an exception might occur. This code should be wrapped in the `try` block to handle any potential exceptions.

- After the `try` block, you can include one or more `catch` blocks. Each `catch` block specifies the type of exception it can handle. If an exception of that type is thrown within the `try` block, the corresponding `catch` block is executed to handle the exception.

- Each `catch` block contains the exception parameter (e.g., `ExceptionType1 e1`) that represents the thrown exception. Within the `catch` block, you can provide specific handling logic to handle the exception, such as displaying an error message, logging, or taking corrective action.

- Multiple `catch` blocks can be chained together to handle different types of exceptions. When an exception occurs, Java matches the exception type with the corresponding `catch` block. If a match is found, the associated `catch` block is executed, and subsequent `catch` blocks are skipped.

- The `finally` block is optional and can be included after the `catch` blocks. It contains code that is always executed, regardless of whether an exception occurred or was caught. The `finally` block is commonly used to perform cleanup operations or release resources, ensuring that certain actions are taken regardless of exception handling.

Here's an example that demonstrates the usage of `try`, `catch`, and `finally` blocks:

```java
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);  // Division by zero
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.out.println("An error occurred: " + e.getMessage());
        } finally {
            System.out.println("Finally block executed");
        }
    }

    public static int divide(int dividend, int divisor) {
        return dividend / divisor;
    }
}
```

In this example, the `divide()` method is called within the `try` block, attempting to perform a division operation. Since division by zero is not allowed, it throws an `ArithmeticException`. The `catch` block with `ArithmeticException` parameter catches the exception and displays an error message.

The program execution continues with the `finally` block, which prints a message indicating that the `finally` block is executed regardless of the exception being thrown or caught.

When you run this code, the output will be:

```
An error occurred: / by zero
Finally block executed
```

As you can see, the `catch` block is executed to handle the `ArithmeticException`, and the `finally` block is always executed afterward.

By using the `try` block, you can isolate and handle exceptions gracefully, allowing your program to recover from errors, maintain control flow, and perform necessary cleanup operations.

---

### 6. Explain the meaning of the following terms :
### a. Method Overloading

### b. Method Overriding

### c. Wrapper Classes

### d. Abstract Classes

### Answer :

(a) Method overloading in Java allows you to define multiple methods with the same name but different parameter lists within the same class. Each overloaded method can have a different number of parameters, different types of parameters, or both. The Java compiler determines which method to invoke based on the arguments passed during the method call.

Method overloading provides flexibility and allows you to create more intuitive and expressive APIs. It makes the code more readable and reduces the need for different method names to perform similar operations.

Here are the key aspects of method overloading:

1. Method Signature: The method signature includes the method name and the parameter list. Two methods with the same name but different parameter lists are considered overloaded. The parameter list can differ in terms of the number of parameters, their types, and their order.

2. Return Type: The return type of the method is not considered during method overloading. Overloaded methods can have the same or different return types.

3. Access Modifiers and Exceptions: Overloaded methods can have different access modifiers (e.g., public, private, protected) and can throw different exceptions. However, these differences alone are not sufficient for method overloading. The parameter list must be different to distinguish between overloaded methods.

4. Overloaded Method Resolution: During method invocation, the Java compiler determines the most appropriate overloaded method based on the arguments passed. The compiler matches the argument types with the parameter types of the available overloaded methods. It tries to find the best match based on the parameter types, preferring an exact match or the closest possible match.

Here's an example that demonstrates method overloading:

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

In this example, the `Calculator` class defines three overloaded methods named `add()`. The first method accepts two integer parameters and returns an integer result. The second method accepts two double parameters and returns a double result. The third method accepts three integer parameters and returns an integer result.

You can use these overloaded methods as follows:

```java
Calculator calc = new Calculator();
int sum1 = calc.add(3, 4);               // Invokes the add(int a, int b) method
double sum2 = calc.add(2.5, 3.7);        // Invokes the add(double a, double b) method
int sum3 = calc.add(1, 2, 3);            // Invokes the add(int a, int b, int c) method
```

The method calls illustrate how the Java compiler determines the appropriate method to invoke based on the provided arguments. The method overloading allows you to use the same method name `add()` for different data types and parameter counts, making the code more concise and readable.

Method overloading is commonly used in Java libraries and frameworks to provide multiple ways of performing similar operations, catering to different scenarios or data types. It enhances code reusability and promotes clean and expressive APIs.

(b) Method overriding in Java allows a subclass to provide its own implementation of a method that is already defined in its superclass. It enables the subclass to modify the behavior of inherited methods to suit its specific requirements. Method overriding is a key concept in achieving polymorphism in object-oriented programming.

To override a method, the following conditions must be met:

1. Inheritance: The method to be overridden must be inherited by the subclass from its superclass.

2. Method Signature: The overriding method in the subclass must have the same name, return type, and the same number and types of parameters as the method in the superclass. The signature of the overriding method must match the signature of the overridden method.

3. Access Modifier: The access modifier of the overriding method in the subclass must be the same or less restrictive than the access modifier of the overridden method in the superclass. It means that an overridden method cannot have a more restrictive access modifier.

4. Exceptions: The overriding method in the subclass can throw the same or a subclass exception compared to the exception thrown by the overridden method. However, the overriding method cannot throw a broader exception or a new exception that is not present in the overridden method.

5. Inheritance Relationship: The subclass must be in an inheritance relationship with the superclass. In other words, the subclass must extend the superclass.

Here's an example that demonstrates method overriding:

```java
class Vehicle {
    public void drive() {
        System.out.println("Driving a vehicle");
    }
}

class Car extends Vehicle {
    @Override
    public void drive() {
        System.out.println("Driving a car");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.drive();  // Output: "Driving a vehicle"

        Car car = new Car();
        car.drive();  // Output: "Driving a car"
    }
}
```

In this example, we have a superclass `Vehicle` with a method `drive()`. The `Car` class extends the `Vehicle` class and overrides the `drive()` method. The `Car` class provides its own implementation of the `drive()` method, which outputs "Driving a car". When we create instances of `Vehicle` and `Car` and invoke the `drive()` method, the appropriate implementation based on the actual object type is called.

Method overriding allows subclasses to extend or specialize the behavior inherited from the superclass. It promotes code reusability, flexibility, and polymorphism. It enables you to write more specific behavior in the subclass while maintaining a common interface and leveraging the principles of inheritance.

(c) In Java, wrapper classes provide a way to convert primitive data types into objects (reference types). Each primitive data type has a corresponding wrapper class that encapsulates the primitive value and provides useful methods for manipulating and working with that value.

The following table shows the primitive data types and their corresponding wrapper classes:

| Primitive Type | Wrapper Class |
|----------------|---------------|
| boolean        | Boolean       |
| byte           | Byte          |
| short          | Short         |
| int            | Integer       |
| long           | Long          |
| float          | Float         |
| double         | Double        |
| char           | Character     |

Wrapper classes are part of the `java.lang` package and provide a way to treat primitive data types as objects. Here are some common scenarios where wrapper classes are useful:

1. Converting between Data Types: Wrapper classes allow you to convert between primitive data types and their corresponding object representations. For example, you can use the `Integer` wrapper class to convert an `int` primitive to an `Integer` object, and vice versa. This conversion is particularly useful when working with APIs or libraries that require objects instead of primitives.

2. Utilizing Collections and Generics: Most Java collection classes, such as `ArrayList` or `HashMap`, can only store objects, not primitives. By using wrapper classes, you can store primitive values in collections by wrapping them with their corresponding wrapper classes. This is especially important when working with generics, as they require reference types.

3. Providing Utility Methods: Wrapper classes provide a set of utility methods to perform various operations on primitive values. For example, the `Integer` class provides methods like `parseInt()` to convert a string representation of an integer to an `int` value, or `toString()` to convert an `int` to its string representation.

4. Boxing and Unboxing: Java supports automatic conversion between primitive types and their corresponding wrapper classes through a process called boxing and unboxing. Boxing refers to the automatic conversion of a primitive value to its wrapper object, while unboxing refers to the automatic extraction of the primitive value from a wrapper object. This allows you to seamlessly work with both primitives and their wrapper objects without explicit conversions.

Here's an example that demonstrates the usage of wrapper classes:

```java
public class WrapperClassExample {
    public static void main(String[] args) {
        // Converting int to Integer
        int num = 10;
        Integer wrappedInt = Integer.valueOf(num);

        // Converting Integer to int (unboxing)
        int unwrappedInt = wrappedInt.intValue();

        // Utility methods of Integer class
        String binaryString = Integer.toBinaryString(num);
        int parsedInt = Integer.parseInt("100");

        // Boxing and unboxing using autoboxing feature
        Integer autoboxedInt = num;
        int autounboxedInt = wrappedInt;

        System.out.println("Wrapped Integer: " + wrappedInt);
        System.out.println("Unwrapped Integer: " + unwrappedInt);
        System.out.println("Binary String: " + binaryString);
        System.out.println("Parsed Integer: " + parsedInt);
        System.out.println("Autoboxed Integer: " + autoboxedInt);
        System.out.println("Autounboxed Integer: " + autounboxedInt);
    }
}
```

In this example, we demonstrate various operations with the `Integer` wrapper class. We convert an `int` to an `Integer` using `valueOf()`, convert it back to `int` using `intValue()`, and use utility methods like `toBinaryString()` and `parseInt()`. Additionally, we showcase autoboxing and autounboxing, where Java automatically converts between primitives and their wrapper classes.

Wrapper classes provide a convenient way to work with primitive types as

 objects in Java, offering additional functionalities and compatibility with object-oriented concepts.

 (d) In Java, an abstract class is a class that cannot be instantiated directly but serves as a blueprint for its subclasses. It is designed to be extended by other classes, which provide concrete implementations for its abstract methods. An abstract class may also contain non-abstract (concrete) methods, fields, and constructors.

Here are the key characteristics and usage of abstract classes:

1. Declaration: An abstract class is declared using the `abstract` keyword before the `class` keyword in its class declaration. For example:

   ```java
   public abstract class Animal {
       // ...
   }
   ```

2. Abstract Methods: An abstract class may include one or more abstract methods. An abstract method is declared without an implementation, using the `abstract` keyword and ending with a semicolon. It provides a contract that must be implemented by its subclasses. Subclasses must override abstract methods and provide their own implementation.

   ```java
   public abstract class Animal {
       public abstract void makeSound();
   }
   ```

3. Concrete Methods: In addition to abstract methods, an abstract class can also include concrete methods (methods with an implementation). Concrete methods provide default behavior that can be inherited and used by subclasses. Subclasses are not required to override or implement concrete methods.

   ```java
   public abstract class Animal {
       public abstract void makeSound();

       public void sleep() {
           System.out.println("Animal is sleeping.");
       }
   }
   ```

4. Partial Implementation: Abstract classes can have both abstract and concrete methods, allowing partial implementation of functionality. Subclasses can inherit and extend the concrete methods while providing their own implementation for abstract methods.

5. Subclassing: Abstract classes are designed to be extended by subclasses. Subclasses must provide implementations for all abstract methods inherited from the abstract class, or they themselves must be declared as abstract classes.

   ```java
   public class Dog extends Animal {
       @Override
       public void makeSound() {
           System.out.println("Dog barks.");
       }
   }
   ```

6. Incomplete Instantiation: Abstract classes cannot be instantiated directly with the `new` keyword. They can only be used as superclasses for creating instances of their concrete subclasses.

   ```java
   Animal animal = new Dog();  // Valid: Abstract class reference pointing to a subclass object
   Animal animal = new Animal();  // Invalid: Cannot instantiate an abstract class
   ```

Abstract classes are used to define common behavior and characteristics among a group of related classes. They provide a level of abstraction and serve as a foundation for creating more specific classes. By defining abstract methods, abstract classes enforce a contract that subclasses must adhere to, ensuring consistent behavior across different implementations.

Here's an example demonstrating the usage of abstract classes:

```java
public abstract class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    public abstract double getArea();

    public void display() {
        System.out.println("This is a " + color + " shape.");
    }
}

public class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle extends Shape {
    private double length;
    private double width;

    public Rectangle(String color, double length, double width) {
        super(color);
        this.length = length;
        this.width = width;
    }

    @Override
    public double getArea() {
        return length * width;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle("Red", 5

.0);
        Shape rectangle = new Rectangle("Blue", 4.0, 6.0);

        circle.display();
        System.out.println("Circle Area: " + circle.getArea());

        rectangle.display();
        System.out.println("Rectangle Area: " + rectangle.getArea());
    }
}
```

In this example, we have an abstract class `Shape` that defines a `color` field, an abstract method `getArea()`, and a concrete method `display()`. The `Circle` and `Rectangle` classes extend the `Shape` class, providing their own implementations for the `getArea()` method. The `Main` class demonstrates creating instances of `Circle` and `Rectangle` and invoking their methods.

Abstract classes allow us to define common functionality and behavior at a higher level of abstraction, while leaving specific implementations to subclasses. They provide a powerful mechanism for achieving code reuse and extensibility in object-oriented programming.

---

## Section B

### 7. (i) Create a class with one integer instance variable. Intialize the variable using :

#### a. Default Constructor

#### b. Parameterized Constructor

### (ii) Write a program to demonstrate the following :

#### a. To convert lowercase letters to uppercase and vice-versa.

#### b. To compare two strings.

### Answer :

(i)

```java
public class MyClass {
    private int value;

    // Default Constructor
    public MyClass() {
        value = 0; // Initialize the value to 0
    }

    // Parameterized Constructor
    public MyClass(int value) {
        this.value = value; // Initialize the value with the provided parameter
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public static void main(String[] args) {
        MyClass obj1 = new MyClass(); // Creating object using default constructor
        System.out.println("Default Constructor - Value: " + obj1.getValue()); // Output: 0

        MyClass obj2 = new MyClass(10); // Creating object using parameterized constructor
        System.out.println("Parameterized Constructor - Value: " + obj2.getValue()); // Output: 10
    }
}
```

In this example, the `MyClass` class has one private integer instance variable `value`. The class provides two constructors - a default constructor and a parameterized constructor.

The default constructor initializes the `value` variable with a default value of 0. It does not take any parameters.

The parameterized constructor accepts an integer value as a parameter and initializes the `value` variable with the provided value.

In the `main` method, we create two objects of the `MyClass` class. The first object (`obj1`) is created using the default constructor, and the second object (`obj2`) is created using the parameterized constructor with the value 10. We then print the values of the `value` variable for both objects to verify the initialization.

Output:
```
Default Constructor - Value: 0
Parameterized Constructor - Value: 10
```

This demonstrates how you can initialize an instance variable using both a default constructor and a parameterized constructor in Java.

(ii)
(a)
```java
public class LetterConverter {
    public static void main(String[] args) {
        String input = "Hello, World!";
        String convertedString = convertLetters(input);
        System.out.println("Converted String: " + convertedString);
    }

    public static String convertLetters(String input) {
        StringBuilder converted = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (Character.isLowerCase(c)) {
                converted.append(Character.toUpperCase(c));
            } else if (Character.isUpperCase(c)) {
                converted.append(Character.toLowerCase(c));
            } else {
                converted.append(c);
            }
        }
        return converted.toString();
    }
}
```

In this program, we have a `LetterConverter` class with a `main` method. The `main` method demonstrates the usage of the `convertLetters` method.

The `convertLetters` method takes a string `input` as a parameter and returns the converted string. It uses a `StringBuilder` to build the converted string character by character. 

Inside the loop, each character `c` of the input string is checked using `Character.isLowerCase(c)` and `Character.isUpperCase(c)` to determine if it is a lowercase or uppercase letter. If it is lowercase, `Character.toUpperCase(c)` is used to convert it to uppercase and appended to the `converted` StringBuilder. If it is uppercase, `Character.toLowerCase(c)` is used to convert it to lowercase and appended to the `converted` StringBuilder. If the character is neither a lowercase nor uppercase letter, it is appended as it is.

Finally, the `converted` StringBuilder is converted to a string using `toString()` and returned as the result.

In the `main` method, we provide an example input string "Hello, World!" and print the converted string.

Output:
```
Converted String: hELLO, wORLD!
```

This program demonstrates how to convert lowercase letters to uppercase and vice versa using the `Character` class in Java.

(b)

```java
public class StringComparator {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = "World";
        
        int result = compareStrings(str1, str2);
        
        if (result == 0) {
            System.out.println("The strings are equal.");
        } else if (result < 0) {
            System.out.println("String 1 is lexicographically smaller than String 2.");
        } else {
            System.out.println("String 1 is lexicographically greater than String 2.");
        }
    }
    
    public static int compareStrings(String str1, String str2) {
        return str1.compareTo(str2);
    }
}
```

In this program, we have a `StringComparator` class with a `main` method. The `main` method demonstrates the usage of the `compareStrings` method.

The `compareStrings` method takes two strings, `str1` and `str2`, as parameters and compares them using the `compareTo` method of the `String` class. The `compareTo` method returns an integer value based on the lexicographical comparison of the strings.

In the `main` method, we initialize `str1` with "Hello" and `str2` with "World". We then call the `compareStrings` method to compare the two strings and store the result in the `result` variable.

We use conditional statements to check the value of `result`. If `result` is 0, it means the strings are equal. If `result` is negative, it means `str1` is lexicographically smaller than `str2`. If `result` is positive, it means `str1` is lexicographically greater than `str2`. We print the corresponding messages based on the comparison result.

Output:
```
String 1 is lexicographically smaller than String 2.
```

This program demonstrates how to compare two strings in Java using the `compareTo` method of the `String` class.

---

### 8. (i) Describe the levels of access protection available for packages.

### (ii) Explain the following methods related to thread:

#### a. start()

#### b. run()

#### c. sleep()

#### d. join()

### (iii) Which is the alternative approach to implement multiple inheritances in Java? Explain with an example.

### Answer :

(i) In Java, there are four levels of access protection available for packages, also known as access modifiers. These access modifiers control the visibility and accessibility of classes, interfaces, and other members within a package. Here are the levels of access protection available for packages, listed in order of increasing restrictiveness:

1. **Default (No Modifier):** When no access modifier is specified, it represents the default level of access. In this level, classes, interfaces, and members are accessible only within the same package. They are not accessible from outside the package. This level of access is also known as package-private or package-level access. To specify default access, simply omit any access modifier.

   Example:
   ```java
   class MyClass { // Default access level
       // Members of MyClass can be accessed within the same package
   }
   ```

2. **Public:** The `public` access modifier provides the highest level of access. Public classes, interfaces, and members are accessible from anywhere, both within and outside the package. They can be accessed by other packages and can be inherited by subclasses in different packages.

   Example:
   ```java
   public class MyClass { // Public access level
       // Members of MyClass can be accessed from anywhere
   }
   ```

3. **Protected:** The `protected` access modifier allows access within the same package and also in subclasses, even if they belong to a different package. Protected members are not directly accessible outside the package unless they are inherited by a subclass.

   Example:
   ```java
   protected class MyClass { // Protected access level
       // Members of MyClass can be accessed within the same package and in subclasses
   }
   ```

4. **Private:** The `private` access modifier provides the most restricted level of access. Private members are accessible only within the same class. They are not visible to any other classes or interfaces, even if they belong to the same package. Private access is commonly used for encapsulation and information hiding.

   Example:
   ```java
   private class MyClass { // Private access level
       // Members of MyClass can be accessed only within the same class
   }
   ```

It's important to note that access modifiers apply to classes, interfaces, constructors, and members such as fields and methods within a package. By using appropriate access modifiers, you can control the visibility and accessibility of your code, promoting encapsulation, modularity, and security.

(ii)

a. `start()`: The `start()` method is used to start a new thread and execute its `run()` method. When `start()` is called, a new thread of execution is created, and the `run()` method of the thread is invoked in a separate thread of control. The `start()` method returns immediately, allowing the newly created thread to run concurrently with other threads.

b. `run()`: The `run()` method is the entry point for the thread's execution. It contains the code that defines the thread's behavior. When a thread is started using the `start()` method, the `run()` method is automatically invoked in a separate thread of control. The thread continues to run until the `run()` method completes or is interrupted.

c. `sleep()`: The `sleep()` method is used to pause the execution of a thread for a specified amount of time. It allows you to introduce delays in the execution of your program. When the `sleep()` method is called, the thread that invokes it is suspended for the specified duration. The duration can be specified in milliseconds (e.g., `Thread.sleep(1000)` pauses the thread for 1 second) or in milliseconds and nanoseconds (e.g., `Thread.sleep(2000, 500000)` pauses the thread for 2 seconds and 500,000 nanoseconds).

d. `join()`: The `join()` method is used to wait for a thread to complete its execution. When a thread invokes the `join()` method on another thread, it waits until that thread finishes executing before proceeding. This is useful when you want to synchronize the execution of multiple threads or when you need the results produced by another thread. The `join()` method can be called with or without a timeout. If a timeout is specified, the calling thread waits for the specified time period, and if the joined thread does not complete within that time, the calling thread resumes its execution.

These methods are commonly used in multithreaded programming to control the execution, synchronization, and timing of threads.

(iii) In Java, the language does not support multiple inheritance, which means a class cannot inherit from multiple classes simultaneously. However, Java provides an alternative approach to achieve similar functionality through interface inheritance.

Interface inheritance allows a class to implement multiple interfaces, thereby inheriting the abstract methods defined in those interfaces. This approach allows a class to exhibit behaviors from multiple sources while avoiding the complications of multiple inheritance.

Here's an example that demonstrates how interface inheritance can be used as an alternative to multiple inheritance in Java:

```java
interface Interface1 {
    void method1();
}

interface Interface2 {
    void method2();
}

class MyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Implementation of method1");
    }

    public void method2() {
        System.out.println("Implementation of method2");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.method1();  // Output: Implementation of method1
        obj.method2();  // Output: Implementation of method2
    }
}
```

In this example, we have two interfaces: `Interface1` and `Interface2`. Each interface defines a single abstract method. The `MyClass` class implements both interfaces, providing the implementations for both `method1()` and `method2()`.

In the `main` method, we create an instance of `MyClass` and call the methods `method1()` and `method2()`. Since `MyClass` implements both interfaces, it is able to provide the required implementations for both methods.

By using interface inheritance, we achieve a form of multiple inheritance in Java, where a class can inherit behaviors from multiple interfaces without inheriting from multiple classes. This approach promotes better code organization, avoids diamond inheritance issues, and enforces a clear separation of concerns.


---

### 9. (i) List Applet initialization and termination methods. Write a Java Applet that sets the background color to cyan and foreground color to red and outputs a string message "A simple Applet".

### (ii) What are Layout Managers? Discuss different types of Layout Managers with examples.

### Answer :


(i) In Java, applets have specific initialization and termination methods that are called during their lifecycle. The initialization methods are used for setting up the applet, while the termination methods are used for cleaning up resources before the applet is stopped or destroyed.

The initialization methods for an applet are as follows:

1. `init()`: This method is called when the applet is first created or initialized. It is used to perform any necessary setup tasks, such as initializing variables, loading resources, or setting initial states.

2. `start()`: This method is called after the `init()` method and when the applet is about to start running. It is used to start any background processes or threads that are required for the applet's functionality.

3. `stop()`: This method is called when the applet is being temporarily stopped, such as when it is covered by another window or tab. It is used to pause or stop any background processes or threads that were started in the `start()` method.

4. `destroy()`: This method is called when the applet is being permanently destroyed or stopped. It is used to clean up any resources used by the applet, such as closing files or releasing system resources.

Now, let's write a Java applet that sets the background color to cyan, foreground color to red, and outputs a string message "A simple Applet":

```java
import java.applet.Applet;
import java.awt.Color;
import java.awt.Graphics;

public class MyCyanApplet extends Applet {
    public void init() {
        setBackground(Color.CYAN);
        setForeground(Color.RED);
    }

    public void paint(Graphics g) {
        g.drawString("A simple Applet", 50, 50);
    }
}
```

In this example, we create a class called `MyCyanApplet` that extends the `Applet` class, which provides the basic functionality for an applet.

In the `init()` method, we set the background color to cyan using `setBackground()` and the foreground color to red using `setForeground()`.

The `paint()` method is overridden to draw the string "A simple Applet" on the applet's surface using the `drawString()` method of the `Graphics` object.

When you compile and run this applet, it will display a cyan-colored background with red-colored text that says "A simple Applet" at the specified coordinates (50, 50).

>Note: Modern web browsers have limited support for Java applets, and they may require additional configurations or plugins to run Java applets properly.

(ii)
In Java, Layout Managers are components that are responsible for arranging and positioning other components within a container. They help in defining the visual structure of a graphical user interface (GUI) by determining the size and location of each component.

Layout Managers automatically handle the resizing and repositioning of components based on the size of the container or changes in the user interface. They ensure that components are displayed appropriately and adapt to different screen sizes and resolutions.

Java provides several types of Layout Managers to suit different GUI design requirements. Here are some commonly used Layout Managers along with their characteristics and examples:

1. **FlowLayout:** This Layout Manager arranges components in a left-to-right flow, wrapping to the next line if necessary. It maintains the order of components and sizes them based on their preferred sizes. It is useful for creating simple, linear layouts.

   ```java
   import javax.swing.*;
   import java.awt.*;

   public class FlowLayoutExample {
       public static void main(String[] args) {
           JFrame frame = new JFrame("Flow Layout Example");
           frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           frame.setLayout(new FlowLayout());

           frame.add(new JButton("Button 1"));
           frame.add(new JButton("Button 2"));
           frame.add(new JButton("Button 3"));
           frame.add(new JButton("Button 4"));

           frame.pack();
           frame.setVisible(true);
       }
   }
   ```

2. **BorderLayout:** This Layout Manager divides the container into five regions: North, South, East, West, and Center. Each region can contain only one component, and the components are stretched to fill their respective regions. It is useful for creating complex layouts with distinct regions.

   ```java
   import javax.swing.*;
   import java.awt.*;

   public class BorderLayoutExample {
       public static void main(String[] args) {
           JFrame frame = new JFrame("Border Layout Example");
           frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           frame.setLayout(new BorderLayout());

           frame.add(new JButton("North"), BorderLayout.NORTH);
           frame.add(new JButton("South"), BorderLayout.SOUTH);
           frame.add(new JButton("East"), BorderLayout.EAST);
           frame.add(new JButton("West"), BorderLayout.WEST);
           frame.add(new JButton("Center"), BorderLayout.CENTER);

           frame.pack();
           frame.setVisible(true);
       }
   }
   ```

3. **GridLayout:** This Layout Manager arranges components in a grid-like structure with a specified number of rows and columns. Each cell of the grid can contain one component, and the components are evenly sized to fill the cells. It is useful for creating uniformly spaced layouts.

   ```java
   import javax.swing.*;
   import java.awt.*;

   public class GridLayoutExample {
       public static void main(String[] args) {
           JFrame frame = new JFrame("Grid Layout Example");
           frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           frame.setLayout(new GridLayout(2, 2));

           frame.add(new JButton("Button 1"));
           frame.add(new JButton("Button 2"));
           frame.add(new JButton("Button 3"));
           frame.add(new JButton("Button 4"));

           frame.pack();
           frame.setVisible(true);
       }
   }
   ```

4. **BoxLayout:** This Layout Manager arranges components in a single row or column, either horizontally or vertically. It supports both X_AXIS and Y_AXIS orientations. It is useful for creating flexible layouts that can adapt to dynamic resizing.

   ```java
   import javax.swing.*;
   import java.awt.*;

   public class BoxLayoutExample {
       public static void main(String[] args) {
           JFrame frame = new JFrame("Box Layout Example");
           frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           frame.setLayout(new BoxLayout(frame.getContentPane(), BoxLayout.Y_AXIS));

           frame.add(new JButton("Button 1"));
           frame.add(new JButton("Button 2"));
           frame.add(new JButton("Button 3"));

           frame.pack();
           frame.setVisible(true);
       }
   }
    ```
---

## Section C

### 10. (i) Define an interface using java that contains a method to calculate the perimeter of an object. Define two classes Circle and Rectangle with suitable fields and methods. Implement the interface "Perimeter" in the classes. Write the appropriate `main()` method to create objects of Circle and Rectangle classes and call the appropriate methods to calculate the perimeter of the objects.

### (ii) What are the uses of exception handling in Java? Write a Java Program that handles an exception "Entry of negative age of a person."

### Answer :

(i)
```java
interface Perimeter {
    double calculatePerimeter();
}

class Circle implements Perimeter {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}

class Rectangle implements Perimeter {
    private double length;
    private double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    public double calculatePerimeter() {
        return 2 * (length + width);
    }
}

public class Main {
    public static void main(String[] args) {
        Circle circle = new Circle(5.0);
        double circlePerimeter = circle.calculatePerimeter();
        System.out.println("Circle Perimeter: " + circlePerimeter);

        Rectangle rectangle = new Rectangle(4.0, 6.0);
        double rectanglePerimeter = rectangle.calculatePerimeter();
        System.out.println("Rectangle Perimeter: " + rectanglePerimeter);
    }
}
```

In this example, we define the interface "Perimeter" with a single method `calculatePerimeter()`. The Circle and Rectangle classes implement this interface and provide their own implementation for the `calculatePerimeter()` method.

In the main method, we create objects of Circle and Rectangle classes, passing the required parameters to their constructors. We then call the `calculatePerimeter()` method on these objects to calculate their respective perimeters.

The output of the program will be:

```
Circle Perimeter: 31.41592653589793
Rectangle Perimeter: 20.0
```

---


(ii) 

Exception handling in Java is used to handle and manage runtime errors or exceptional conditions that may occur during the execution of a program. It provides a structured way to handle and recover from exceptional situations, ensuring that the program doesn't abruptly terminate and allowing for proper error reporting and handling.

Some common uses of exception handling in Java include:

1. **Error Reporting:** Exceptions provide a mechanism to report and communicate errors or exceptional conditions that occur during program execution. They help in identifying the cause of the error and provide useful information for debugging and troubleshooting.

2. **Program Flow Control:** Exceptions allow for the control of program flow when an exceptional condition occurs. By catching and handling exceptions, the program can gracefully handle errors and take appropriate actions instead of abruptly terminating.

3. **Resource Management:** Exceptions play a crucial role in managing resources such as files, network connections, database connections, etc. They ensure that resources are properly released or closed even in the presence of exceptions, preventing resource leaks and maintaining system stability.

4. **Robustness and Reliability:** Exception handling improves the robustness and reliability of a program by providing a way to recover from unexpected situations. It allows for graceful degradation, error handling, and fallback mechanisms, enhancing the overall stability and usability of the application.

Now, let's write a Java program that handles the exception of entering a negative age for a person:

```java
import java.util.Scanner;

public class NegativeAgeExceptionExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        try {
            System.out.print("Enter age: ");
            int age = scanner.nextInt();

            if (age < 0) {
                throw new NegativeAgeException("Negative age not allowed");
            }

            System.out.println("Age entered: " + age);
        } catch (NegativeAgeException e) {
            System.out.println("Exception: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Exception occurred: " + e.getMessage());
        } finally {
            scanner.close();
        }
    }
}

class NegativeAgeException extends Exception {
    public NegativeAgeException(String message) {
        super(message);
    }
}
```

In this program, we take input from the user for the age of a person. We use a try-catch block to handle any exceptions that may occur during the execution of the program.

Inside the try block, we check if the age entered is negative. If it is, we explicitly throw a custom exception called "NegativeAgeException" with an appropriate error message.

In the catch block, we catch the NegativeAgeException and print the error message. We also have a general catch block that catches any other exceptions that may occur and prints their error messages.

Finally, in the `finally` block, we close the Scanner object to release system resources.

